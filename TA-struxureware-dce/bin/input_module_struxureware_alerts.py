# encoding = utf-8import osimport sysimport timeimport datetime'''    IMPORTANT    Edit only the validate_input and collect_events functions.    Do not edit any other part in this file.    This file is generated only once when creating the modular input.''''''# For advanced users, if you want to create single instance mod input, uncomment this method.def use_single_instance_mode():    return True'''def validate_input(helper, definition):    """Implement your own validation logic to validate the input stanza configurations"""    # This example accesses the modular input variable    # global_account = definition.parameters.get('global_account', None)    passdef collect_events(helper, ew):    import json    import requests    import collections    from xml.etree.ElementTree import fromstring, ElementTree    from datetime import datetime    #Define variables for try/catch    global_account = ''    username = ''    password = ''    dce_server = ''    url = ''    response = ''    try:        global_account = helper.get_arg('dce_account')                username = global_account['username']        password = global_account['password']    except:        helper.log_critical("Unable to retrieve credentials from vault")    try:        dce_server = helper.get_global_setting('dce_server')        url="http://" + dce_server + "/integration/services/ISXCentralAlarmsService_v2_0"    except:        helper.log_critical("Unable to retrieve DCE server information")    header = {'content-type': 'application/soap+xml'}    body = """    <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:isx="http://www.apc.com/stdws/xsd/ISXCentralAlarms-v2">        <soapenv:Header/>            <soapenv:Body>                <isx:getAllActiveAlarmsRequest>                </isx:getAllActiveAlarmsRequest>            </soapenv:Body>        </soapenv:Envelope>    """        proxy_settings = helper.get_proxy()    helper.log_info("Initiating request to " + url)    if len(proxy_settings)>0:        helper.log_debug("Proxy enabled")        proxy = {            'http' : 'http://' + proxy_settings['proxy_url'] + ':' + proxy_settings['proxy_port'],            'https' : 'https://' + proxy_settings['proxy_url'] + ':' + proxy_settings['proxy_port']        }        try:            response = requests.get(url, 'GET', auth=(username,password), headers=header, data=body, proxies=proxy)        except:            helper.log_error("Unable to contact url through proxy")    else:        try:            response = requests.get(url, 'GET', auth=(username,password), headers=header, data=body)        except:            helper.log_error("Unable to contact url")    rawdata = response.content    helper.log_debug("Full content of SOAP response: " + rawdata)    tree = ElementTree(fromstring(rawdata))    root = tree.getroot()    mylog = ''    for elem in root.iter():        if 'ISXCElementType' in elem.tag:            mylog += str(datetime.now())            mylog+=', ISXCElementType' + '="' + str(elem.text) + '"'        elif 'id' in elem.tag:            mylog+= ', id' + '="' + str(elem.text) + '"'        elif 'activeTime' in elem.tag:            mylog+= ', activeTime' + '="' + str(elem.text) + '"'        elif 'ISXCAlarmSeverity' in elem.tag:            mylog+= ', ISXCAlarmSeverity' + ' ="' + str(elem.text) + '"'        elif 'ISXCAlarmState' in elem.tag:            mylog+= ', ISXCAlarmState' + '="' + str(elem.text) + '"'        elif 'description' in elem.tag:            mylog+= ', description' + '="' + str(elem.text) + '"'        elif 'deviceID' in elem.tag:            mylog+= ', deviceID' + '="' + str(elem.text) + '"'        elif 'recommendedAction' in elem.tag:            mylog+= ', recommendedAction' + '="' + str(elem.text) + '"'        elif 'resolvedTime' in elem.tag:            mylog+= ', resolvedTime' + '="' + str(elem.text) + '"'        elif 'sensorID' in elem.tag:            mylog+= ', sensorID' + '="' + str(elem.text) + '"\n'    #event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=mylog)    event = helper.new_event(source=helper.get_input_type(), host=dce_server, index=helper.get_global_setting('dce_index'), sourcetype=helper.get_sourcetype(), data=mylog)    ew.write_event(event)    helper.log_debug("Parsing response complete")